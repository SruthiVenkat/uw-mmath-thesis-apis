%======================================================================
\chapter{Introduction}
%======================================================================
\label{sec:introduction}

The long-term aspiration for software component reuse has finally arrived. This vision---of a component ecosystem enabling ubiquitous reuse and economies of scale---was first proposed over 50 years ago~\cite{mcilroy1968mass} and has finally become reality. Today's applications are largely built from existing components (with one major exception being embedded or safety-critical systems). A key contributor to this shift was the emergence of open source component repositories. Tools such as Maven and npm lower the barriers for using third-party components through automated dependency resolution. Developers can easily include functionality from third-party components in their projects. The size and growth rate of these repositories is staggering. 

Virtually all modern software projects use libraries, driven in part by the ease of dependency resolution build tools like Maven and npm. Library developers design Application Programming Interfaces, or APIs, for their libraries, and clients invoke these APIs. APIs typically provide clients with methods that can be invoked, fields that can be accessed, classes that can be instantiated or inherited from, and annotations that can be used. We use the term ``API surface'' to denote the APIs that a library makes available to other code artifacts (its clients). Myers and Stylos~\cite{myers-cacm-2016}, and many others, have advocated for the importance of easy-to-use and maintainable API surfaces.


\section{Motivation}
\label{sec:motivation}

Reusing functionality provided by third-party components saves time and increases modularity of software. However, there are no silver bullets in software engineering~\cite{frederick87:_no_silver_bullet}. Component reuse comes with important trade-offs. The number of dependencies used by modern software has exploded, and so has their complexity~\cite{kikas2017structure,benelallam2019maven}: deeper, transitive dependencies are now common, components are upgraded more frequently, and developers increasingly struggle to deal with issues arising from those changes, such as: (1) dealing with conflicting versions of the same component (also known as dependency hell) and dealing with supply chain vulnerabilities of deep dependencies (often notified by bots creating pull requests); (2) new issues around security and resilience of the software supply chains, for example, problems with changes to commodity components (as in the infamous left-pad incident~\cite{collins16:_how}) and novel attack patterns like typosquatting; and, (3) the use of unnecessary, bloated, and trivial dependencies~\cite{abdalkareem2017developers,soto2021comprehensive}.

So, components are revolutionary but bring new problems. Let's consider one problem: breaking changes. By breaking change, we mean a change in an external dependency which could break its client, either syntactically or semantically. \textit{Potentially} breaking changes in library APIs are common~\cite{dietrich2014broken,raemaekers2014semantic}. However, any library change is only potentially breaking; does it \textit{actually} break any particular client? Only if a client uses a specific component API with an incompatible change. Under plain Java (i.e. no runtime containers) and considering reflection, the API surface of any component is huge. Essentially: every method can be called, and every field can be read and written. In the history of Java (and other languages), several constructs enable component developers to better define and enforce the API surface, including access modifiers, modules, and bundles restricting access to packages, and packaging of components that only expose ``services'', i.e. instantiable classes implementing some abstract type that specifies the service. However, these restrictions always have to compete with the need to provide runtime introspection and code generation features. There are clear benefits in restricting the API surface: such restrictions can facilitate analyses that can calculate whether breaking changes are \textit{likely} to actually break clients.  In terms of precision, added restrictions to the API surface would facilitate breakage analyses with fewer false positives (i.e., increased precision). 

As a second problem, consider the detection of vulnerabilities in dependencies. Detection is relatively straight-forward: compute the transitive closure of all dependencies, and cross-reference the transitive dependencies with vulnerability databases like CVEs. Tools like \textit{snyk} and \textit{dependabot} are based on this general idea. Some languages and build systems like npm have built-in language-specific support (\textit{npm audit}). The problem is again precision---listing something as a dependency does not mean that all of its functionality is used. So, if dependencies are sufficiently large and deep, a conservative approach inevitably results in false positives. Indeed, Elizalde Zapata et al~\cite{elizalde18:_towar_smoot_librar_migrat} found that 73\% of their studied clients with theoretically vulnerable dependencies were not actually at risk from CVEs in those dependencies, and Chinthanet et al~\cite{chinthanet20:_code_based_vulner_detec_node} implemented a code-based vulnerability detection tool for Node.js applications. Like the boy who cried wolf, false positives can lead to a potentially devastating impact on application security when true positives start being ignored, as demonstrated in the infamous Equifax incident~\cite{luszcz2018apache}. Sadowski et al~\cite{sadowski2018lessons}, among others, also cite the necessity for low false positive rates in developer tools.

We study software component usage and explore its usefulness in this work. Specifically, our research aims to explore the following questions: is the API surface huge in practice? How much of it is actually used and in what ways is it used? Ought we better control component use? What are some ways to do so? 

We look at API surface usage and API bypasses in our study. We also present a classification framework for classifying API uses and present different usage patterns, including expected and unexpected ones. 

We also apply our results and identify two applications based on them--- VizAPI and library fission. We introduce VizAPI to help library developers, client developers and researchers to visually understand API usage. To mitigate the issue of huge API surfaces and multiple, complex dependencies, we introduce the concept of library fission. By observing how clients use libraries in practice, we can propose splitting libraries into loosely confederated modules. Then, a client can depend on some subset of the library’s modules. This has implications both on safe upgrades and on security vulnerabilities. Upgrades are
 safe if potentially-breaking changes are in unused components. And, security vulnerabilities in unused components are less likely to cause problems in their clients.

\section{Contributions}
\label{sec:contributions}

The contributions of this work include:
\begin{itemize}
\item a tool to record both static and dynamic interactions between clients, the libraries they use, and those libraries’ direct dependencies
\item a detailed empirical study of API usage patterns on 11 libraries and 90 clients 
\item VizAPI, a tool which presents visualization of API usage information
\item a case study on the concept of library fission
\end{itemize}

Our tool collects static information and also instruments Java code to collect dynamic instrumentation data about API uses in practice. This includes different patterns of interactions across components, such as vanilla invocations, field usage, annotation usage, subtyping, dynamic proxies, reflective calls and service loaders. 

Using the tool's output, we empirically study how developers access libraries in practice, so that we (and others) can develop tools to help developers achieve more stability. Additionally, we present a classification framework to help developers classify different API uses. We conduct our study on a corpus of 11 open-source libraries and 90 clients. We have generated API usage data for this corpus of 101 projects, which we have made publicly available. 

Our visualization tool, VizAPI, presents this information about API uses in practice as a d3 visualization, which can be useful to component developers when they want to introspect about their software. 

We also apply the API usage information to explore the concept of library fission. We define library fission as splitting up a component into smaller sub-modules. The possible advantages of library fission includes lesser chances of breaking changes in clients of the library, and lesser chances of vulnerabilities and version conflicts introduced through dependencies.
